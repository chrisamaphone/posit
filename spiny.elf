base : type.
arb : base.

base_value : base -> type.
bv : base_value arb.

ty+ : type.
t1    : ty+.
tprod : ty+ -> ty+ -> ty+.
tsum  : ty+ -> ty+ -> ty+.
tbase : base -> ty+.

ty- : type.
tr : ty+ -> ty- -> ty-.
ret : ty+ -> ty-.

% values: inhabitants of positive types
value : ty+ -> type.
unit : value t1.
pair : value A -> value B -> value (tprod A B).
inl  : value A -> value (tsum A B).
inr  : value B -> value (tsum A B).
vbase : base_value P -> value (tbase P).

% transformations: deconstructors of positive types
% analogous to left rules of sequent calculus
trans : ty- -> type.
ignore : trans T -> trans (tr t1 T).  % could be "trans A C" in general
split : (value A -> value B -> trans T) -> trans (tr (tprod A B) T).
case : (value A -> trans T) -> (value B -> trans T) 
        -> trans (tr (tsum A B) T).
% case : (value A -> value C) -> (value B -> value C) 
%        -> trans (tsum A B) C.
use : value A -> trans (ret A).
select : value A -> trans (tr A T) -> trans T.
% id : trans A A.
% seq : trans A B -> trans B C -> trans A C.

% eval
eval : value A -> trans (tr A (ret C)) -> value C -> type.
%mode eval +Val +Trans -Val2.

% TODO

% eval : value T -> trans T C -> value C -> type.
% %mode eval +Value +Trans -Value2.
% eval/split
%   : eval (pair V1 V2) (split Cont) V
%     <- eval V2 (Cont V1) V.
% eval/ignore
%   : eval unit (ignore V) V.
% eval/case/inl
%   : eval (inl V1) (case T1 T2) V
%   <- eval V1 T1 V.
% eval/case/inr
%   : eval (inr V2) (case T1 T2) V
%   <- eval V2 T2 V.
% eval/bind
%   : eval V (bind ([x] V' x)) (V' V).
% 
% 
% a : base.
% b : base.
% c : base.
% 
% a_val : base_value a.
% b_val : base_value b.
% c_val : base_value c.
% 
% example1 : trans 
%                (tprod (tbase a) (tsum (tbase b) (tbase c))) 
%                (tsum (tprod (tbase a) (tbase b)) (tbase c)).
% example1 = split ([x] case (bind [z] inl (pair x z)) (bind [w] inr w)).
% example1_in = pair (vbase a_val) (inl (vbase b_val)).
% 
% %solve example_eval : eval example1_in example1 Out.
% 


